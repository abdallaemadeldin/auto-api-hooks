/**
 * Axios hook generator.
 *
 * Generates React hooks using useState + useEffect + axios.
 */
import type { ApiOperation, ApiSpec } from '../ir/types'
import type { GeneratorOptions } from './types'
import { BaseHookGenerator } from './base-generator'
import { toPascalCase } from '../utils/naming'

export class AxiosGenerator extends BaseHookGenerator {
  protected generateClientConfig(spec: ApiSpec, options: GeneratorOptions) {
    const baseUrl = options.baseUrl || spec.baseUrl || ''
    return {
      path: 'client.ts',
      content: [
        `/**`,
        ` * Axios API client configuration.`,
        ` * Generated by auto-api-hooks — do not edit manually.`,
        ` */`,
        `import axios from 'axios'`,
        ``,
        `export const API_BASE_URL = '${baseUrl}'`,
        ``,
        `export const apiClient = axios.create({`,
        `  baseURL: API_BASE_URL,`,
        `  headers: { 'Content-Type': 'application/json' },`,
        `})`,
        ``,
        `/**`,
        ` * Configure the API client.`,
        ` */`,
        `export function configureClient(config: { baseUrl?: string; headers?: Record<string, string> }): void {`,
        `  if (config.baseUrl) apiClient.defaults.baseURL = config.baseUrl`,
        `  if (config.headers) Object.assign(apiClient.defaults.headers.common, config.headers)`,
        `}`,
        ``,
      ].join('\n'),
    }
  }

  protected generateHookFile(
    op: ApiOperation,
    hookName: string,
    _spec: ApiSpec,
    options: GeneratorOptions,
  ): string {
    const paramsType = this.getParamsTypeName(op.operationId)
    const responseType = this.getResponseTypeName(op.operationId)
    const bodyType = op.requestBody ? this.getBodyTypeName(op.operationId) : null
    const hasParams = op.pathParams.length > 0 || op.queryParams.length > 0
    const isRead = this.isReadOperation(op)

    const imports: string[] = [
      `import type { ${[paramsType, responseType, bodyType].filter(Boolean).join(', ')} } from '../types'`,
      `import { apiClient } from '../client'`,
    ]

    if (isRead) {
      imports.unshift(`import { useState, useEffect, useCallback, useRef } from 'react'`)
    } else {
      imports.unshift(`import { useState, useCallback } from 'react'`)
    }

    if (options.zod) {
      const schemaVar = `${toPascalCase(op.operationId).charAt(0).toLowerCase() + toPascalCase(op.operationId).slice(1)}ResponseSchema`
      imports.push(`import { ${schemaVar} } from '../schemas'`)
    }

    const lines: string[] = [
      `/**`,
      ` * ${op.summary || `${op.method} ${op.path}`}`,
      ` *`,
      ` * \`${op.method} ${op.path}\``,
      op.deprecated ? ` * @deprecated` : '',
      ` * Generated by auto-api-hooks — do not edit manually.`,
      ` */`,
      ...imports,
      ``,
    ].filter(Boolean)

    if (isRead) {
      lines.push(...this.generateReadHook(op, hookName, paramsType, responseType, hasParams, options))
    } else {
      lines.push(...this.generateWriteHook(op, hookName, paramsType, responseType, bodyType, hasParams, options))
    }

    return lines.join('\n') + '\n'
  }

  private generateReadHook(
    op: ApiOperation,
    hookName: string,
    paramsType: string,
    responseType: string,
    hasParams: boolean,
    options: GeneratorOptions,
  ): string[] {
    const paramArg = hasParams ? `params: ${paramsType}` : ''
    const args = [paramArg, `options?: { enabled?: boolean }`].filter(Boolean).join(', ')
    const schemaVar = `${toPascalCase(op.operationId).charAt(0).toLowerCase() + toPascalCase(op.operationId).slice(1)}ResponseSchema`

    let pathExpr = `'${op.path}'`
    if (op.pathParams.length > 0) {
      let tmpl = op.path
      for (const p of op.pathParams) {
        tmpl = tmpl.replace(`{${p.name}}`, `\${params.${p.name}}`)
      }
      pathExpr = `\`${tmpl}\``
    }

    const queryParams = op.queryParams.length > 0
      ? `params: { ${op.queryParams.map((p) => `${p.name}: params.${p.name}`).join(', ')} },`
      : ''

    return [
      `export interface ${hookName}Result {`,
      `  data: ${responseType} | null`,
      `  error: Error | null`,
      `  isLoading: boolean`,
      `  refetch: () => void`,
      `}`,
      ``,
      `export function ${hookName}(${args}): ${hookName}Result {`,
      `  const [data, setData] = useState<${responseType} | null>(null)`,
      `  const [error, setError] = useState<Error | null>(null)`,
      `  const [isLoading, setIsLoading] = useState(false)`,
      `  const cancelRef = useRef<(() => void) | null>(null)`,
      ``,
      `  const fetchData = useCallback(async () => {`,
      `    if (options?.enabled === false) return`,
      `    cancelRef.current?.()`,
      `    const source = new AbortController()`,
      `    cancelRef.current = () => source.abort()`,
      ``,
      `    setIsLoading(true)`,
      `    setError(null)`,
      ``,
      `    try {`,
      `      const res = await apiClient.get<${responseType}>(${pathExpr}, {`,
      queryParams ? `        ${queryParams}` : '',
      `        signal: source.signal,`,
      `      })`,
      options.zod
        ? `      const parsed = ${schemaVar}.parse(res.data)\n      setData(parsed as ${responseType})`
        : `      setData(res.data)`,
      `    } catch (err) {`,
      `      if (!source.signal.aborted) {`,
      `        setError(err instanceof Error ? err : new Error(String(err)))`,
      `      }`,
      `    } finally {`,
      `      setIsLoading(false)`,
      `    }`,
      `  // eslint-disable-next-line react-hooks/exhaustive-deps`,
      `  }, [${hasParams ? 'JSON.stringify(params)' : ''}])`,
      ``,
      `  useEffect(() => {`,
      `    fetchData()`,
      `    return () => { cancelRef.current?.() }`,
      `  }, [fetchData])`,
      ``,
      `  return { data, error, isLoading, refetch: fetchData }`,
      `}`,
    ].filter(Boolean)
  }

  private generateWriteHook(
    op: ApiOperation,
    hookName: string,
    paramsType: string,
    responseType: string,
    bodyType: string | null,
    hasParams: boolean,
    options: GeneratorOptions,
  ): string[] {
    const mutateArgs: string[] = []
    if (hasParams) mutateArgs.push(`params: ${paramsType}`)
    if (bodyType) mutateArgs.push(`body: ${bodyType}`)
    const mutateArgStr = mutateArgs.join(', ')
    const schemaVar = `${toPascalCase(op.operationId).charAt(0).toLowerCase() + toPascalCase(op.operationId).slice(1)}ResponseSchema`

    let pathExpr = `'${op.path}'`
    if (op.pathParams.length > 0) {
      let tmpl = op.path
      for (const p of op.pathParams) {
        tmpl = tmpl.replace(`{${p.name}}`, `\${params.${p.name}}`)
      }
      pathExpr = `\`${tmpl}\``
    }

    const methodLower = op.method.toLowerCase()
    const axiosCall = bodyType
      ? `apiClient.${methodLower}<${responseType}>(${pathExpr}, body)`
      : `apiClient.${methodLower}<${responseType}>(${pathExpr})`

    return [
      `export interface ${hookName}Result {`,
      `  data: ${responseType} | null`,
      `  error: Error | null`,
      `  isLoading: boolean`,
      `  mutate: (${mutateArgStr}) => Promise<${responseType}>`,
      `  reset: () => void`,
      `}`,
      ``,
      `export function ${hookName}(): ${hookName}Result {`,
      `  const [data, setData] = useState<${responseType} | null>(null)`,
      `  const [error, setError] = useState<Error | null>(null)`,
      `  const [isLoading, setIsLoading] = useState(false)`,
      ``,
      `  const mutate = useCallback(async (${mutateArgStr}): Promise<${responseType}> => {`,
      `    setIsLoading(true)`,
      `    setError(null)`,
      ``,
      `    try {`,
      `      const res = await ${axiosCall}`,
      options.zod
        ? `      const parsed = ${schemaVar}.parse(res.data)\n      setData(parsed as ${responseType})\n      return parsed as ${responseType}`
        : `      setData(res.data)\n      return res.data`,
      `    } catch (err) {`,
      `      const error = err instanceof Error ? err : new Error(String(err))`,
      `      setError(error)`,
      `      throw error`,
      `    } finally {`,
      `      setIsLoading(false)`,
      `    }`,
      `  }, [])`,
      ``,
      `  const reset = useCallback(() => {`,
      `    setData(null)`,
      `    setError(null)`,
      `    setIsLoading(false)`,
      `  }, [])`,
      ``,
      `  return { data, error, isLoading, mutate, reset }`,
      `}`,
    ]
  }
}
