/**
 * Plain fetch hook generator.
 *
 * Generates React hooks using useState + useEffect + fetch.
 */
import type { ApiOperation, ApiSpec } from '../ir/types'
import type { GeneratorOptions } from './types'
import { BaseHookGenerator } from './base-generator'
import { toPascalCase } from '../utils/naming'

export class FetchGenerator extends BaseHookGenerator {
  protected generateHookFile(
    op: ApiOperation,
    hookName: string,
    _spec: ApiSpec,
    options: GeneratorOptions,
  ): string {
    const paramsType = this.getParamsTypeName(op.operationId)
    const responseType = this.getResponseTypeName(op.operationId)
    const bodyType = op.requestBody ? this.getBodyTypeName(op.operationId) : null
    const hasParams = op.pathParams.length > 0 || op.queryParams.length > 0
    const isRead = this.isReadOperation(op)

    const lines: string[] = [
      `/**`,
      ` * ${op.summary || `${op.method} ${op.path}`}`,
      ` *`,
      ` * \`${op.method} ${op.path}\``,
      op.deprecated ? ` * @deprecated` : '',
      ` * Generated by auto-api-hooks â€” do not edit manually.`,
      ` */`,
      `import { useState, useEffect, useCallback, useRef } from 'react'`,
      `import { getClientConfig } from '../client'`,
      `import type { ${[paramsType, responseType, bodyType].filter(Boolean).join(', ')} } from '../types'`,
    ].filter(Boolean)

    if (options.zod) {
      const schemaName = `${toPascalCase(op.operationId)}ResponseSchema`
      lines.push(`import { ${schemaName.charAt(0).toLowerCase() + schemaName.slice(1)} } from '../schemas'`)
    }

    lines.push(``)

    if (isRead) {
      lines.push(...this.generateReadHook(op, hookName, paramsType, responseType, hasParams, options))
    } else {
      lines.push(...this.generateWriteHook(op, hookName, paramsType, responseType, bodyType, hasParams, options))
    }

    return lines.join('\n') + '\n'
  }

  private generateReadHook(
    op: ApiOperation,
    hookName: string,
    paramsType: string,
    responseType: string,
    hasParams: boolean,
    options: GeneratorOptions,
  ): string[] {
    const paramArg = hasParams ? `params: ${paramsType}` : ''
    const enabledArg = `options?: { enabled?: boolean }`
    const args = [paramArg, enabledArg].filter(Boolean).join(', ')

    return [
      `export interface ${hookName}Result {`,
      `  data: ${responseType} | null`,
      `  error: Error | null`,
      `  isLoading: boolean`,
      `  refetch: () => void`,
      `}`,
      ``,
      `export function ${hookName}(${args}): ${hookName}Result {`,
      `  const [data, setData] = useState<${responseType} | null>(null)`,
      `  const [error, setError] = useState<Error | null>(null)`,
      `  const [isLoading, setIsLoading] = useState(false)`,
      `  const abortRef = useRef<AbortController | null>(null)`,
      ``,
      `  const fetchData = useCallback(async () => {`,
      `    if (options?.enabled === false) return`,
      `    abortRef.current?.abort()`,
      `    const controller = new AbortController()`,
      `    abortRef.current = controller`,
      ``,
      `    setIsLoading(true)`,
      `    setError(null)`,
      ``,
      `    try {`,
      `      const config = getClientConfig()`,
      `      const url = buildUrl(config.baseUrl, ${hasParams ? 'params' : 'undefined'})`,
      `      const res = await fetch(url, {`,
      `        method: '${op.method}',`,
      `        headers: { 'Content-Type': 'application/json', ...config.headers },`,
      `        signal: controller.signal,`,
      `      })`,
      ``,
      `      if (!res.ok) throw new Error(\`HTTP \${res.status}: \${res.statusText}\`)`,
      ``,
      options.zod
        ? `      const json = await res.json()\n      const parsed = ${toPascalCase(op.operationId).charAt(0).toLowerCase() + toPascalCase(op.operationId).slice(1)}ResponseSchema.parse(json)\n      setData(parsed as ${responseType})`
        : `      const json = await res.json()\n      setData(json as ${responseType})`,
      `    } catch (err) {`,
      `      if (err instanceof Error && err.name !== 'AbortError') {`,
      `        setError(err)`,
      `      }`,
      `    } finally {`,
      `      setIsLoading(false)`,
      `    }`,
      `  // eslint-disable-next-line react-hooks/exhaustive-deps`,
      `  }, [${hasParams ? 'JSON.stringify(params)' : ''}])`,
      ``,
      `  useEffect(() => {`,
      `    fetchData()`,
      `    return () => { abortRef.current?.abort() }`,
      `  }, [fetchData])`,
      ``,
      `  return { data, error, isLoading, refetch: fetchData }`,
      `}`,
      ``,
      ...this.generateBuildUrl(op),
    ]
  }

  private generateWriteHook(
    op: ApiOperation,
    hookName: string,
    paramsType: string,
    responseType: string,
    bodyType: string | null,
    hasParams: boolean,
    options: GeneratorOptions,
  ): string[] {
    const mutateArgs: string[] = []
    if (hasParams) mutateArgs.push(`params: ${paramsType}`)
    if (bodyType) mutateArgs.push(`body: ${bodyType}`)
    const mutateArgStr = mutateArgs.join(', ')

    return [
      `export interface ${hookName}Result {`,
      `  data: ${responseType} | null`,
      `  error: Error | null`,
      `  isLoading: boolean`,
      `  mutate: (${mutateArgStr}) => Promise<${responseType}>`,
      `  reset: () => void`,
      `}`,
      ``,
      `export function ${hookName}(): ${hookName}Result {`,
      `  const [data, setData] = useState<${responseType} | null>(null)`,
      `  const [error, setError] = useState<Error | null>(null)`,
      `  const [isLoading, setIsLoading] = useState(false)`,
      ``,
      `  const mutate = useCallback(async (${mutateArgStr}): Promise<${responseType}> => {`,
      `    setIsLoading(true)`,
      `    setError(null)`,
      ``,
      `    try {`,
      `      const config = getClientConfig()`,
      `      const url = buildUrl(config.baseUrl, ${hasParams ? 'params' : 'undefined'})`,
      `      const res = await fetch(url, {`,
      `        method: '${op.method}',`,
      `        headers: { 'Content-Type': 'application/json', ...config.headers },`,
      bodyType ? `        body: JSON.stringify(body),` : '',
      `      })`,
      ``,
      `      if (!res.ok) throw new Error(\`HTTP \${res.status}: \${res.statusText}\`)`,
      ``,
      options.zod
        ? `      const json = await res.json()\n      const parsed = ${toPascalCase(op.operationId).charAt(0).toLowerCase() + toPascalCase(op.operationId).slice(1)}ResponseSchema.parse(json)\n      setData(parsed as ${responseType})\n      return parsed as ${responseType}`
        : `      const json = await res.json()\n      setData(json as ${responseType})\n      return json as ${responseType}`,
      `    } catch (err) {`,
      `      const error = err instanceof Error ? err : new Error(String(err))`,
      `      setError(error)`,
      `      throw error`,
      `    } finally {`,
      `      setIsLoading(false)`,
      `    }`,
      `  }, [])`,
      ``,
      `  const reset = useCallback(() => {`,
      `    setData(null)`,
      `    setError(null)`,
      `    setIsLoading(false)`,
      `  }, [])`,
      ``,
      `  return { data, error, isLoading, mutate, reset }`,
      `}`,
      ``,
      ...this.generateBuildUrl(op),
    ].filter(Boolean)
  }

  private generateBuildUrl(op: ApiOperation): string[] {
    const hasPathParams = op.pathParams.length > 0
    const hasQueryParams = op.queryParams.length > 0
    const paramsType = this.getParamsTypeName(op.operationId)
    const hasAnyParams = hasPathParams || hasQueryParams

    if (!hasAnyParams) {
      return [
        `function buildUrl(baseUrl: string, _params: undefined): string {`,
        `  return \`\${baseUrl}${op.path}\``,
        `}`,
      ]
    }

    let pathTemplate = op.path
    for (const p of op.pathParams) {
      pathTemplate = pathTemplate.replace(`{${p.name}}`, `\${params.${p.name}}`)
    }

    const lines: string[] = [
      `function buildUrl(baseUrl: string, params: ${paramsType}): string {`,
      `  let url = \`\${baseUrl}${pathTemplate}\``,
    ]

    if (hasQueryParams) {
      lines.push(
        `  const query = new URLSearchParams()`,
      )
      for (const p of op.queryParams) {
        lines.push(
          `  if (params.${p.name} !== undefined) query.set('${p.name}', String(params.${p.name}))`,
        )
      }
      lines.push(
        `  const qs = query.toString()`,
        `  if (qs) url += \`?\${qs}\``,
      )
    }

    lines.push(
      `  return url`,
      `}`,
    )

    return lines
  }
}
