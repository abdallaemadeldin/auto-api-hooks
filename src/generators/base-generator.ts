/**
 * Abstract base class for all hook generators.
 *
 * Provides shared functionality: type file generation, grouping by tags,
 * barrel index generation, client config.
 */
import type { ApiSpec, ApiOperation } from '../ir/types'
import type { HookGenerator, GeneratorOptions } from './types'
import type { GeneratedFile } from '../utils/file-writer'
import { emitTypeScriptTypes } from '../type-gen/typescript-emitter'
import { emitZodSchemas } from '../type-gen/zod-emitter'
import { toKebabCase, toPascalCase, getHookName } from '../utils/naming'

export abstract class BaseHookGenerator implements HookGenerator {
  /**
   * Generate all files for the given spec.
   */
  generate(spec: ApiSpec, options: GeneratorOptions): GeneratedFile[] {
    const files: GeneratedFile[] = []

    // 1. Generate types file
    files.push({
      path: 'types.ts',
      content: emitTypeScriptTypes(spec),
    })

    // 2. Generate Zod schemas (if enabled)
    if (options.zod) {
      files.push({
        path: 'schemas.ts',
        content: emitZodSchemas(spec),
      })
    }

    // 3. Generate client config
    files.push(this.generateClientConfig(spec, options))

    // 4. Group operations by tag
    const groups = this.groupByTag(spec.operations)

    // 5. Generate hook files per group
    const hookExports: string[] = []

    for (const [tag, operations] of groups) {
      const groupFiles = this.generateHookGroup(tag, operations, spec, options)
      files.push(...groupFiles)
      hookExports.push(tag)
    }

    // 6. Generate barrel index
    files.push(this.generateBarrelIndex(hookExports, options))

    return files
  }

  /**
   * Generate hooks for a single tag group.
   * Subclasses implement generateHookFile for each operation.
   */
  protected generateHookGroup(
    tag: string,
    operations: ApiOperation[],
    spec: ApiSpec,
    options: GeneratorOptions,
  ): GeneratedFile[] {
    const files: GeneratedFile[] = []
    const tagDir = toKebabCase(tag)
    const exportNames: string[] = []

    for (const op of operations) {
      const hookName = getHookName(op.operationId, op.method, op.path)
      const fileName = toKebabCase(hookName.replace(/^use/, ''))

      const hookFile = this.generateHookFile(op, hookName, spec, options)
      files.push({
        path: `${tagDir}/${fileName}.ts`,
        content: hookFile,
      })

      exportNames.push(hookName)

      // Generate infinite query variant if applicable
      if (options.infiniteQueries && op.pagination && this.supportsInfiniteQueries()) {
        const infiniteName = `${hookName}Infinite`
        const infiniteFile = this.generateInfiniteHookFile(op, infiniteName, spec, options)
        if (infiniteFile) {
          files.push({
            path: `${tagDir}/${fileName}-infinite.ts`,
            content: infiniteFile,
          })
          exportNames.push(infiniteName)
        }
      }
    }

    // Group barrel index
    const groupExports = exportNames
      .map((name) => {
        const fileName = toKebabCase(name.replace(/^use/, ''))
        return `export { ${name} } from './${fileName}'`
      })
      .join('\n')

    files.push({
      path: `${tagDir}/index.ts`,
      content: `${groupExports}\n`,
    })

    return files
  }

  /**
   * Generate the base API client configuration file.
   */
  protected generateClientConfig(spec: ApiSpec, options: GeneratorOptions): GeneratedFile {
    const baseUrl = options.baseUrl || spec.baseUrl || ''
    return {
      path: 'client.ts',
      content: [
        `/**`,
        ` * API client configuration.`,
        ` * Generated by auto-api-hooks — do not edit manually.`,
        ` */`,
        ``,
        `export const API_BASE_URL = '${baseUrl}'`,
        ``,
        `export interface ClientConfig {`,
        `  baseUrl: string`,
        `  headers?: Record<string, string>`,
        `}`,
        ``,
        `let _config: ClientConfig = {`,
        `  baseUrl: API_BASE_URL,`,
        `}`,
        ``,
        `/**`,
        ` * Configure the API client.`,
        ` */`,
        `export function configureClient(config: Partial<ClientConfig>): void {`,
        `  _config = { ..._config, ...config }`,
        `}`,
        ``,
        `/**`,
        ` * Get the current client configuration.`,
        ` */`,
        `export function getClientConfig(): ClientConfig {`,
        `  return _config`,
        `}`,
        ``,
      ].join('\n'),
    }
  }

  /**
   * Generate the barrel index file.
   */
  protected generateBarrelIndex(
    tagGroups: string[],
    options: GeneratorOptions,
  ): GeneratedFile {
    const lines: string[] = [
      `/**`,
      ` * Auto-generated API hooks.`,
      ` * Generated by auto-api-hooks — do not edit manually.`,
      ` */`,
      ``,
      `export * from './types'`,
      `export * from './client'`,
    ]

    if (options.zod) {
      lines.push(`export * from './schemas'`)
    }

    for (const tag of tagGroups) {
      lines.push(`export * from './${toKebabCase(tag)}'`)
    }

    lines.push(``)

    return {
      path: 'index.ts',
      content: lines.join('\n'),
    }
  }

  /**
   * Group operations by their first tag.
   */
  protected groupByTag(operations: ApiOperation[]): Map<string, ApiOperation[]> {
    const groups = new Map<string, ApiOperation[]>()

    for (const op of operations) {
      const tag = op.tags[0] || 'default'
      const group = groups.get(tag) || []
      group.push(op)
      groups.set(tag, group)
    }

    return groups
  }

  /**
   * Get the params type name for an operation.
   */
  protected getParamsTypeName(operationId: string): string {
    return `${toPascalCase(operationId)}Params`
  }

  /**
   * Get the request body type name for an operation.
   */
  protected getBodyTypeName(operationId: string): string {
    return `${toPascalCase(operationId)}Body`
  }

  /**
   * Get the response type name for an operation.
   */
  protected getResponseTypeName(operationId: string): string {
    return `${toPascalCase(operationId)}Response`
  }

  /**
   * Check if an operation is a "read" operation (GET or QUERY).
   */
  protected isReadOperation(op: ApiOperation): boolean {
    return op.method === 'GET' || op.method === 'QUERY'
  }

  /**
   * Check if an operation is a "write" operation (POST, PUT, PATCH, DELETE, MUTATION).
   */
  protected isWriteOperation(op: ApiOperation): boolean {
    return !this.isReadOperation(op)
  }

  /**
   * Whether this generator supports infinite queries.
   * Override in subclasses that support them (react-query, swr).
   */
  protected supportsInfiniteQueries(): boolean {
    return false
  }

  /**
   * Generate a single hook file for an operation.
   * Subclasses must implement this.
   */
  protected abstract generateHookFile(
    op: ApiOperation,
    hookName: string,
    spec: ApiSpec,
    options: GeneratorOptions,
  ): string

  /**
   * Generate an infinite query hook file for a paginated operation.
   * Override in subclasses that support infinite queries.
   */
  protected generateInfiniteHookFile(
    _op: ApiOperation,
    _hookName: string,
    _spec: ApiSpec,
    _options: GeneratorOptions,
  ): string | null {
    return null
  }
}
