/**
 * Abstract base class for all hook generators.
 *
 * Provides shared functionality: type file generation, grouping by tags,
 * barrel index generation, client config.
 */
import type { ApiSpec, ApiOperation } from '../ir/types'
import type { HookGenerator, GeneratorOptions } from './types'
import type { GeneratedFile } from '../utils/file-writer'
import { emitTypeScriptTypes } from '../type-gen/typescript-emitter'
import { emitZodSchemas } from '../type-gen/zod-emitter'
import { toKebabCase, toPascalCase, getHookName } from '../utils/naming'
import { logger } from '../utils/logger'

export abstract class BaseHookGenerator implements HookGenerator {
  /**
   * Generate all files for the given spec.
   */
  generate(spec: ApiSpec, options: GeneratorOptions): GeneratedFile[] {
    const files: GeneratedFile[] = []

    // 1. Generate types file
    files.push({
      path: 'types.ts',
      content: emitTypeScriptTypes(spec),
    })

    // 2. Generate Zod schemas (if enabled)
    if (options.zod) {
      files.push({
        path: 'schemas.ts',
        content: emitZodSchemas(spec),
      })
    }

    // 3. Generate client config
    files.push(this.generateClientConfig(spec, options))

    // 4. Detect hook name collisions before generating
    this.detectHookNameCollisions(spec.operations)

    // 5. Group operations by tag
    const groups = this.groupByTag(spec.operations)

    // 6. Generate hook files per group
    const hookExports: string[] = []

    for (const [tag, operations] of groups) {
      const groupFiles = this.generateHookGroup(tag, operations, spec, options)
      files.push(...groupFiles)
      hookExports.push(tag)
    }

    // 7. Generate barrel index
    files.push(this.generateBarrelIndex(hookExports, options))

    return files
  }

  /**
   * Generate hooks for a single tag group.
   * Subclasses implement generateHookFile for each operation.
   */
  protected generateHookGroup(
    tag: string,
    operations: ApiOperation[],
    spec: ApiSpec,
    options: GeneratorOptions,
  ): GeneratedFile[] {
    const files: GeneratedFile[] = []
    const tagDir = toKebabCase(tag)
    const exportNames: string[] = []

    for (const op of operations) {
      const hookName = getHookName(op.operationId, op.method, op.path)
      const fileName = toKebabCase(hookName.replace(/^use/, ''))

      // Route subscription operations to dedicated generator
      let hookFile: string
      if (this.isSubscriptionOperation(op)) {
        hookFile = this.generateSubscriptionHookFile(op, hookName, spec, options)
      } else {
        hookFile = this.generateHookFile(op, hookName, spec, options)
      }

      files.push({
        path: `${tagDir}/${fileName}.ts`,
        content: hookFile,
      })

      exportNames.push(hookName)

      // Generate infinite query variant if applicable
      if (options.infiniteQueries && op.pagination && this.supportsInfiniteQueries()) {
        const infiniteName = `${hookName}Infinite`
        const infiniteFile = this.generateInfiniteHookFile(op, infiniteName, spec, options)
        if (infiniteFile) {
          files.push({
            path: `${tagDir}/${fileName}-infinite.ts`,
            content: infiniteFile,
          })
          exportNames.push(infiniteName)
        }
      }
    }

    // Group barrel index
    const groupExports = exportNames
      .map((name) => {
        const fileName = toKebabCase(name.replace(/^use/, ''))
        return `export { ${name} } from './${fileName}'`
      })
      .join('\n')

    files.push({
      path: `${tagDir}/index.ts`,
      content: `${groupExports}\n`,
    })

    return files
  }

  /**
   * Generate the base API client configuration file.
   */
  protected generateClientConfig(spec: ApiSpec, options: GeneratorOptions): GeneratedFile {
    const baseUrl = options.baseUrl || spec.baseUrl || ''
    return {
      path: 'client.ts',
      content: [
        `/**`,
        ` * API client configuration.`,
        ` * Generated by auto-api-hooks — do not edit manually.`,
        ` */`,
        ``,
        `export const API_BASE_URL = '${baseUrl}'`,
        ``,
        `export interface ClientConfig {`,
        `  baseUrl: string`,
        `  headers?: Record<string, string>`,
        `}`,
        ``,
        `let _config: ClientConfig = {`,
        `  baseUrl: API_BASE_URL,`,
        `}`,
        ``,
        `/**`,
        ` * Configure the API client.`,
        ` */`,
        `export function configureClient(config: Partial<ClientConfig>): void {`,
        `  _config = { ..._config, ...config }`,
        `}`,
        ``,
        `/**`,
        ` * Get the current client configuration.`,
        ` */`,
        `export function getClientConfig(): ClientConfig {`,
        `  return _config`,
        `}`,
        ``,
      ].join('\n'),
    }
  }

  /**
   * Generate the barrel index file.
   */
  protected generateBarrelIndex(
    tagGroups: string[],
    options: GeneratorOptions,
  ): GeneratedFile {
    const lines: string[] = [
      `/**`,
      ` * Auto-generated API hooks.`,
      ` * Generated by auto-api-hooks — do not edit manually.`,
      ` */`,
      ``,
      `export * from './types'`,
      `export * from './client'`,
    ]

    if (options.zod) {
      lines.push(`export * from './schemas'`)
    }

    for (const tag of tagGroups) {
      lines.push(`export * from './${toKebabCase(tag)}'`)
    }

    lines.push(``)

    return {
      path: 'index.ts',
      content: lines.join('\n'),
    }
  }

  /**
   * Group operations by their first tag.
   */
  protected groupByTag(operations: ApiOperation[]): Map<string, ApiOperation[]> {
    const groups = new Map<string, ApiOperation[]>()

    for (const op of operations) {
      const tag = op.tags[0] || 'default'
      const group = groups.get(tag) || []
      group.push(op)
      groups.set(tag, group)
    }

    return groups
  }

  /**
   * Detect and warn about hook name collisions across all operations.
   * Two operations mapping to the same hook name will overwrite each other.
   */
  protected detectHookNameCollisions(operations: ApiOperation[]): void {
    const seen = new Map<string, ApiOperation>()

    for (const op of operations) {
      const hookName = getHookName(op.operationId, op.method, op.path)
      const existing = seen.get(hookName)

      if (existing) {
        logger.warn(
          `Hook name collision: "${hookName}" is generated by both ` +
          `"${existing.method} ${existing.path}" (${existing.operationId}) and ` +
          `"${op.method} ${op.path}" (${op.operationId}). ` +
          `The second will overwrite the first. Consider using unique operationId values.`,
        )
      }

      seen.set(hookName, op)
    }
  }

  /**
   * Get the params type name for an operation.
   */
  protected getParamsTypeName(operationId: string): string {
    return `${toPascalCase(operationId)}Params`
  }

  /**
   * Get the request body type name for an operation.
   */
  protected getBodyTypeName(operationId: string): string {
    return `${toPascalCase(operationId)}Body`
  }

  /**
   * Get the response type name for an operation.
   */
  protected getResponseTypeName(operationId: string): string {
    return `${toPascalCase(operationId)}Response`
  }

  /**
   * Check if an operation is a "read" operation (GET or QUERY).
   */
  protected isReadOperation(op: ApiOperation): boolean {
    return op.method === 'GET' || op.method === 'QUERY'
  }

  /**
   * Check if an operation is a "write" operation (POST, PUT, PATCH, DELETE, MUTATION).
   */
  protected isWriteOperation(op: ApiOperation): boolean {
    return !this.isReadOperation(op) && !this.isSubscriptionOperation(op)
  }

  /**
   * Check if an operation is a GraphQL subscription.
   */
  protected isSubscriptionOperation(op: ApiOperation): boolean {
    return op.method === 'SUBSCRIPTION'
  }

  /**
   * Whether this generator supports infinite queries.
   * Override in subclasses that support them (react-query, swr).
   */
  protected supportsInfiniteQueries(): boolean {
    return false
  }

  /**
   * Generate a single hook file for an operation.
   * Subclasses must implement this.
   */
  protected abstract generateHookFile(
    op: ApiOperation,
    hookName: string,
    spec: ApiSpec,
    options: GeneratorOptions,
  ): string

  /**
   * Generate an infinite query hook file for a paginated operation.
   * Override in subclasses that support infinite queries.
   */
  protected generateInfiniteHookFile(
    _op: ApiOperation,
    _hookName: string,
    _spec: ApiSpec,
    _options: GeneratorOptions,
  ): string | null {
    return null
  }

  /**
   * Generate a subscription hook file for a GraphQL subscription.
   * Default implementation generates a generic EventSource/callback-based hook.
   * Override in subclasses for library-specific implementations.
   */
  protected generateSubscriptionHookFile(
    op: ApiOperation,
    hookName: string,
    _spec: ApiSpec,
    _options: GeneratorOptions,
  ): string {
    const responseType = this.getResponseTypeName(op.operationId)
    const hasArgs = op.queryParams.length > 0
    const paramsType = this.getParamsTypeName(op.operationId)

    const paramArg = hasArgs ? `variables: ${paramsType}` : ''
    const callbackArg = `onData: (data: ${responseType}) => void`
    const optionsArg = `options?: { onError?: (error: Error) => void; onComplete?: () => void }`
    const args = [paramArg, callbackArg, optionsArg].filter(Boolean).join(', ')

    const typeImports = hasArgs ? `${paramsType}, ${responseType}` : responseType

    const lines: string[] = [
      `/**`,
      ` * ${op.summary || `SUBSCRIPTION ${op.path}`}`,
      ` *`,
      ` * GraphQL Subscription: \`${op.path}\``,
      op.deprecated ? ` * @deprecated` : '',
      ` * Generated by auto-api-hooks — do not edit manually.`,
      ` */`,
      `import { useEffect, useRef, useState, useCallback } from 'react'`,
      `import { getClientConfig } from '../client'`,
      `import type { ${typeImports} } from '../types'`,
      ``,
      `export interface ${hookName}Result {`,
      `  data: ${responseType} | null`,
      `  error: Error | null`,
      `  isConnected: boolean`,
      `  unsubscribe: () => void`,
      `}`,
      ``,
      `export function ${hookName}(${args}): ${hookName}Result {`,
      `  const [data, setData] = useState<${responseType} | null>(null)`,
      `  const [error, setError] = useState<Error | null>(null)`,
      `  const [isConnected, setIsConnected] = useState(false)`,
      `  const wsRef = useRef<WebSocket | null>(null)`,
      ``,
      `  const unsubscribe = useCallback(() => {`,
      `    if (wsRef.current) {`,
      `      wsRef.current.close()`,
      `      wsRef.current = null`,
      `      setIsConnected(false)`,
      `    }`,
      `  }, [])`,
      ``,
      `  useEffect(() => {`,
      `    const config = getClientConfig()`,
      `    const wsUrl = config.baseUrl.replace(/^http/, 'ws')`,
      `    const ws = new WebSocket(wsUrl, 'graphql-ws')`,
      `    wsRef.current = ws`,
      ``,
      `    ws.onopen = () => {`,
      `      setIsConnected(true)`,
      `      ws.send(JSON.stringify({`,
      `        type: 'start',`,
      `        payload: {`,
      `          query: \`subscription { ${op.path}${hasArgs ? '(${Object.entries(variables).map(([k, v]) => `${k}: ${JSON.stringify(v)}`).join(", ")})' : ''} { __typename } }\`,`,
      hasArgs ? `          variables,` : '',
      `        },`,
      `      }))`,
      `    }`,
      ``,
      `    ws.onmessage = (event) => {`,
      `      try {`,
      `        const message = JSON.parse(event.data as string)`,
      `        if (message.type === 'data' && message.payload?.data?.${op.path}) {`,
      `          const value = message.payload.data.${op.path} as ${responseType}`,
      `          setData(value)`,
      `          onData(value)`,
      `        }`,
      `      } catch (err) {`,
      `        const parseError = err instanceof Error ? err : new Error(String(err))`,
      `        setError(parseError)`,
      `        options?.onError?.(parseError)`,
      `      }`,
      `    }`,
      ``,
      `    ws.onerror = () => {`,
      `      const wsError = new Error('WebSocket connection error')`,
      `      setError(wsError)`,
      `      options?.onError?.(wsError)`,
      `    }`,
      ``,
      `    ws.onclose = () => {`,
      `      setIsConnected(false)`,
      `      options?.onComplete?.()`,
      `    }`,
      ``,
      `    return () => {`,
      `      ws.close()`,
      `    }`,
      `  // eslint-disable-next-line react-hooks/exhaustive-deps`,
      `  }, [${hasArgs ? 'JSON.stringify(variables)' : ''}])`,
      ``,
      `  return { data, error, isConnected, unsubscribe }`,
      `}`,
      ``,
    ].filter(Boolean)

    return lines.join('\n')
  }
}
