/**
 * TanStack React Query v5 hook generator.
 *
 * Generates:
 * - useQuery hooks for GET operations
 * - useMutation hooks for POST/PUT/PATCH/DELETE operations
 * - useInfiniteQuery hooks for paginated GET operations
 * - Cache key factory objects per resource
 */
import type { ApiOperation, ApiSpec, PaginationInfo } from '../ir/types'
import type { GeneratorOptions } from './types'
import type { GeneratedFile } from '../utils/file-writer'
import { BaseHookGenerator } from './base-generator'
import { toPascalCase } from '../utils/naming'
import { deriveCacheKeyFactories, getQueryKey } from '../utils/cache-keys'

export class ReactQueryGenerator extends BaseHookGenerator {
  protected supportsInfiniteQueries(): boolean {
    return true
  }

  generate(spec: ApiSpec, options: GeneratorOptions): GeneratedFile[] {
    const files = super.generate(spec, options)

    // Add query keys file
    files.push(this.generateQueryKeysFile(spec))

    return files
  }

  /**
   * Generate the query-keys.ts file with cache key factories.
   */
  private generateQueryKeysFile(spec: ApiSpec): GeneratedFile {
    const factories = deriveCacheKeyFactories(spec.operations)
    const lines: string[] = [
      `/**`,
      ` * Query key factories for TanStack React Query.`,
      ` * Generated by auto-api-hooks — do not edit manually.`,
      ` */`,
      ``,
    ]

    for (const factory of factories) {
      lines.push(
        `export const ${factory.variableName} = {`,
        `  all: [${factory.rootKey.map((k) => `'${k}'`).join(', ')}] as const,`,
      )
      if (factory.hasList) {
        lines.push(
          `  lists: () => [...${factory.variableName}.all, 'list'] as const,`,
          `  list: (params?: Record<string, unknown>) => [...${factory.variableName}.lists(), params] as const,`,
        )
      }
      if (factory.hasDetail) {
        lines.push(
          `  details: () => [...${factory.variableName}.all, 'detail'] as const,`,
          `  detail: (id: string | number) => [...${factory.variableName}.details(), id] as const,`,
        )
      }
      lines.push(`} as const`, ``)
    }

    return {
      path: 'query-keys.ts',
      content: lines.join('\n'),
    }
  }

  protected generateBarrelIndex(
    tagGroups: string[],
    options: GeneratorOptions,
  ): GeneratedFile {
    const base = super.generateBarrelIndex(tagGroups, options)
    // Add query-keys export
    const content = base.content.replace(
      `export * from './client'`,
      `export * from './client'\nexport * from './query-keys'`,
    )
    return { ...base, content }
  }

  protected generateHookFile(
    op: ApiOperation,
    hookName: string,
    _spec: ApiSpec,
    options: GeneratorOptions,
  ): string {
    const isRead = this.isReadOperation(op)
    return isRead
      ? this.generateQueryHook(op, hookName, options)
      : this.generateMutationHook(op, hookName, options)
  }

  protected generateSubscriptionHookFile(
    op: ApiOperation,
    hookName: string,
    _spec: ApiSpec,
    _options: GeneratorOptions,
  ): string {
    return this.generateSubscriptionHook(op, hookName)
  }

  protected generateInfiniteHookFile(
    op: ApiOperation,
    hookName: string,
    _spec: ApiSpec,
    options: GeneratorOptions,
  ): string | null {
    if (!op.pagination) return null
    return this.generateInfiniteQueryHook(op, hookName, op.pagination, options)
  }

  // ---------------------------------------------------------------------------
  // useQuery
  // ---------------------------------------------------------------------------

  private generateQueryHook(
    op: ApiOperation,
    hookName: string,
    options: GeneratorOptions,
  ): string {
    const paramsType = this.getParamsTypeName(op.operationId)
    const responseType = this.getResponseTypeName(op.operationId)
    const hasParams = op.pathParams.length > 0 || op.queryParams.length > 0
    const queryKey = getQueryKey(op)
    const schemaVar = `${toPascalCase(op.operationId).charAt(0).toLowerCase() + toPascalCase(op.operationId).slice(1)}ResponseSchema`

    const paramArg = hasParams ? `params: ${paramsType}` : ''
    const optionsArg = `options?: Partial<UseQueryOptions<${responseType}, Error>>`
    const args = [paramArg, optionsArg].filter(Boolean).join(', ')

    const fetcherBody = this.generateFetcherBody(op, options)

    const lines: string[] = [
      `/**`,
      ` * ${op.summary || `${op.method} ${op.path}`}`,
      ` *`,
      ` * \`${op.method} ${op.path}\``,
      op.deprecated ? ` * @deprecated` : '',
      ` * Generated by auto-api-hooks — do not edit manually.`,
      ` */`,
      `import { useQuery } from '@tanstack/react-query'`,
      `import type { UseQueryOptions } from '@tanstack/react-query'`,
      `import { getClientConfig } from '../client'`,
      `import type { ${[paramsType, responseType].filter(Boolean).join(', ')} } from '../types'`,
    ].filter(Boolean)

    if (options.zod) {
      lines.push(`import { ${schemaVar} } from '../schemas'`)
    }

    lines.push(
      ``,
      `export function ${hookName}(${args}) {`,
      `  return useQuery<${responseType}, Error>({`,
      `    queryKey: ${queryKey},`,
      `    queryFn: async () => {`,
      ...fetcherBody.map((l) => `      ${l}`),
      `    },`,
      `    ...options,`,
      `  })`,
      `}`,
      ``,
    )

    return lines.join('\n')
  }

  // ---------------------------------------------------------------------------
  // useMutation
  // ---------------------------------------------------------------------------

  private generateMutationHook(
    op: ApiOperation,
    hookName: string,
    options: GeneratorOptions,
  ): string {
    const paramsType = this.getParamsTypeName(op.operationId)
    const responseType = this.getResponseTypeName(op.operationId)
    const bodyType = op.requestBody ? this.getBodyTypeName(op.operationId) : null
    const hasParams = op.pathParams.length > 0 || op.queryParams.length > 0
    const schemaVar = `${toPascalCase(op.operationId).charAt(0).toLowerCase() + toPascalCase(op.operationId).slice(1)}ResponseSchema`

    // Build the mutation variables type
    const varFields: string[] = []
    if (hasParams) varFields.push(`params: ${paramsType}`)
    if (bodyType) varFields.push(`body: ${bodyType}`)
    const varsType = varFields.length > 0 ? `{ ${varFields.join('; ')} }` : 'void'

    const fetcherBody = this.generateMutationFetcherBody(op, options)

    const typeImports = [paramsType, responseType, bodyType].filter(Boolean).join(', ')

    const lines: string[] = [
      `/**`,
      ` * ${op.summary || `${op.method} ${op.path}`}`,
      ` *`,
      ` * \`${op.method} ${op.path}\``,
      op.deprecated ? ` * @deprecated` : '',
      ` * Generated by auto-api-hooks — do not edit manually.`,
      ` */`,
      `import { useMutation } from '@tanstack/react-query'`,
      `import type { UseMutationOptions } from '@tanstack/react-query'`,
      `import { getClientConfig } from '../client'`,
      `import type { ${typeImports} } from '../types'`,
    ].filter(Boolean)

    if (options.zod) {
      lines.push(`import { ${schemaVar} } from '../schemas'`)
    }

    lines.push(
      ``,
      `export function ${hookName}(options?: UseMutationOptions<${responseType}, Error, ${varsType}>) {`,
      `  return useMutation<${responseType}, Error, ${varsType}>({`,
      `    mutationFn: async (${varFields.length > 0 ? 'vars' : ''}) => {`,
      ...fetcherBody.map((l) => `      ${l}`),
      `    },`,
      `    ...options,`,
      `  })`,
      `}`,
      ``,
    )

    return lines.join('\n')
  }

  // ---------------------------------------------------------------------------
  // useInfiniteQuery
  // ---------------------------------------------------------------------------

  private generateInfiniteQueryHook(
    op: ApiOperation,
    hookName: string,
    pagination: PaginationInfo,
    options: GeneratorOptions,
  ): string {
    const paramsType = this.getParamsTypeName(op.operationId)
    const responseType = this.getResponseTypeName(op.operationId)
    const hasParams = op.queryParams.length > 1 || op.pathParams.length > 0 // >1 because one is the page param
    const queryKey = getQueryKey(op)
    const schemaVar = `${toPascalCase(op.operationId).charAt(0).toLowerCase() + toPascalCase(op.operationId).slice(1)}ResponseSchema`

    const pageParamType = pagination.strategy === 'cursor' ? 'string | undefined' : 'number'
    const initialPageParam = pagination.strategy === 'cursor' ? 'undefined' : pagination.strategy === 'offset-limit' ? '0' : '1'
    const nextPagePath = pagination.nextPagePath.join('?.')

    const paramArg = hasParams ? `params: Omit<${paramsType}, '${pagination.pageParam}'>` : ''
    const optionsArg = `options?: Partial<UseInfiniteQueryOptions<${responseType}, Error>>`
    const args = [paramArg, optionsArg].filter(Boolean).join(', ')

    const lines: string[] = [
      `/**`,
      ` * ${op.summary || `${op.method} ${op.path}`} (infinite)`,
      ` *`,
      ` * \`${op.method} ${op.path}\``,
      op.deprecated ? ` * @deprecated` : '',
      ` * Generated by auto-api-hooks — do not edit manually.`,
      ` */`,
      `import { useInfiniteQuery } from '@tanstack/react-query'`,
      `import type { UseInfiniteQueryOptions } from '@tanstack/react-query'`,
      `import { getClientConfig } from '../client'`,
      `import type { ${[paramsType, responseType].filter(Boolean).join(', ')} } from '../types'`,
    ].filter(Boolean)

    if (options.zod) {
      lines.push(`import { ${schemaVar} } from '../schemas'`)
    }

    // Build the fetcher path
    let pathExpr = `'${op.path}'`
    if (op.pathParams.length > 0) {
      let tmpl = op.path
      for (const p of op.pathParams) {
        tmpl = tmpl.replace(`{${p.name}}`, `\${params.${p.name}}`)
      }
      pathExpr = `\`${tmpl}\``
    }

    lines.push(
      ``,
      `export function ${hookName}(${args}) {`,
      `  return useInfiniteQuery<${responseType}, Error>({`,
      `    queryKey: ${queryKey},`,
      `    queryFn: async ({ pageParam }) => {`,
      `      const config = getClientConfig()`,
      `      const url = new URL(${pathExpr}, config.baseUrl)`,
    )

    // Add query params
    for (const p of op.queryParams) {
      if (p.name === pagination.pageParam) {
        lines.push(`      if (pageParam !== undefined) url.searchParams.set('${p.name}', String(pageParam))`)
      } else {
        lines.push(`      if (${hasParams ? `params.${p.name}` : 'undefined'} !== undefined) url.searchParams.set('${p.name}', String(${hasParams ? `params.${p.name}` : ''}))`)
      }
    }

    lines.push(
      `      const res = await fetch(url.toString(), {`,
      `        headers: { 'Content-Type': 'application/json', ...config.headers },`,
      `      })`,
      `      if (!res.ok) throw new Error(\`HTTP \${res.status}: \${res.statusText}\`)`,
    )

    if (options.zod) {
      lines.push(
        `      const json = await res.json()`,
        `      return ${schemaVar}.parse(json) as ${responseType}`,
      )
    } else {
      lines.push(`      return (await res.json()) as ${responseType}`)
    }

    lines.push(
      `    },`,
      `    initialPageParam: ${initialPageParam} as ${pageParamType},`,
      `    getNextPageParam: (lastPage) => (lastPage as Record<string, unknown>)?.${nextPagePath} as ${pageParamType},`,
      `    ...options,`,
      `  })`,
      `}`,
      ``,
    )

    return lines.join('\n')
  }

  // ---------------------------------------------------------------------------
  // useSubscription (custom hook — TanStack Query has no native subscription)
  // ---------------------------------------------------------------------------

  private generateSubscriptionHook(
    op: ApiOperation,
    hookName: string,
  ): string {
    const responseType = this.getResponseTypeName(op.operationId)
    const hasArgs = op.queryParams.length > 0
    const paramsType = this.getParamsTypeName(op.operationId)

    const paramArg = hasArgs ? `variables: ${paramsType}` : ''
    const optionsArg = `options?: { onData?: (data: ${responseType}) => void; onError?: (error: Error) => void; enabled?: boolean }`
    const args = [paramArg, optionsArg].filter(Boolean).join(', ')

    const typeImports = hasArgs ? `${paramsType}, ${responseType}` : responseType

    const lines: string[] = [
      `/**`,
      ` * ${op.summary || `SUBSCRIPTION ${op.path}`}`,
      ` *`,
      ` * GraphQL Subscription: \`${op.path}\``,
      ` *`,
      ` * Note: TanStack Query does not natively support subscriptions.`,
      ` * This hook uses a WebSocket connection with React state management.`,
      op.deprecated ? ` * @deprecated` : '',
      ` * Generated by auto-api-hooks — do not edit manually.`,
      ` */`,
      `import { useState, useEffect, useRef, useCallback } from 'react'`,
      `import { useQueryClient } from '@tanstack/react-query'`,
      `import { getClientConfig } from '../client'`,
      `import type { ${typeImports} } from '../types'`,
      ``,
      `export interface ${hookName}Result {`,
      `  data: ${responseType} | null`,
      `  error: Error | null`,
      `  status: 'connecting' | 'connected' | 'disconnected' | 'error'`,
      `  unsubscribe: () => void`,
      `}`,
      ``,
      `export function ${hookName}(${args}): ${hookName}Result {`,
      `  const queryClient = useQueryClient()`,
      `  const [data, setData] = useState<${responseType} | null>(null)`,
      `  const [error, setError] = useState<Error | null>(null)`,
      `  const [status, setStatus] = useState<'connecting' | 'connected' | 'disconnected' | 'error'>('disconnected')`,
      `  const wsRef = useRef<WebSocket | null>(null)`,
      ``,
      `  const unsubscribe = useCallback(() => {`,
      `    if (wsRef.current) {`,
      `      wsRef.current.close()`,
      `      wsRef.current = null`,
      `      setStatus('disconnected')`,
      `    }`,
      `  }, [])`,
      ``,
      `  useEffect(() => {`,
      `    if (options?.enabled === false) return`,
      ``,
      `    const config = getClientConfig()`,
      `    const wsUrl = config.baseUrl.replace(/^http/, 'ws')`,
      `    const ws = new WebSocket(wsUrl, 'graphql-ws')`,
      `    wsRef.current = ws`,
      `    setStatus('connecting')`,
      ``,
      `    ws.onopen = () => {`,
      `      setStatus('connected')`,
      `      ws.send(JSON.stringify({`,
      `        type: 'start',`,
      `        id: '${op.operationId}',`,
      `        payload: {`,
      `          query: \`subscription { ${op.path} { __typename } }\`,`,
      hasArgs ? `          variables,` : '',
      `        },`,
      `      }))`,
      `    }`,
      ``,
      `    ws.onmessage = (event) => {`,
      `      try {`,
      `        const message = JSON.parse(event.data as string)`,
      `        if (message.type === 'data' && message.payload?.data?.${op.path}) {`,
      `          const value = message.payload.data.${op.path} as ${responseType}`,
      `          setData(value)`,
      `          options?.onData?.(value)`,
      `          // Invalidate related queries so they refetch fresh data`,
      `          queryClient.invalidateQueries()`,
      `        }`,
      `      } catch (err) {`,
      `        const parseError = err instanceof Error ? err : new Error(String(err))`,
      `        setError(parseError)`,
      `        setStatus('error')`,
      `        options?.onError?.(parseError)`,
      `      }`,
      `    }`,
      ``,
      `    ws.onerror = () => {`,
      `      const wsError = new Error('WebSocket connection error')`,
      `      setError(wsError)`,
      `      setStatus('error')`,
      `      options?.onError?.(wsError)`,
      `    }`,
      ``,
      `    ws.onclose = () => {`,
      `      setStatus('disconnected')`,
      `    }`,
      ``,
      `    return () => {`,
      `      ws.close()`,
      `    }`,
      `  // eslint-disable-next-line react-hooks/exhaustive-deps`,
      `  }, [${hasArgs ? 'JSON.stringify(variables)' : ''}])`,
      ``,
      `  return { data, error, status, unsubscribe }`,
      `}`,
      ``,
    ].filter(Boolean)

    return lines.join('\n')
  }

  // ---------------------------------------------------------------------------
  // Shared fetcher body generators
  // ---------------------------------------------------------------------------

  private generateFetcherBody(op: ApiOperation, options: GeneratorOptions): string[] {
    const responseType = this.getResponseTypeName(op.operationId)
    const schemaVar = `${toPascalCase(op.operationId).charAt(0).toLowerCase() + toPascalCase(op.operationId).slice(1)}ResponseSchema`

    let pathExpr = `'${op.path}'`
    if (op.pathParams.length > 0) {
      let tmpl = op.path
      for (const p of op.pathParams) {
        tmpl = tmpl.replace(`{${p.name}}`, `\${params.${p.name}}`)
      }
      pathExpr = `\`${tmpl}\``
    }

    const lines: string[] = [
      `const config = getClientConfig()`,
      `const url = new URL(${pathExpr}, config.baseUrl)`,
    ]

    for (const p of op.queryParams) {
      lines.push(`if (params.${p.name} !== undefined) url.searchParams.set('${p.name}', String(params.${p.name}))`)
    }

    lines.push(
      `const res = await fetch(url.toString(), {`,
      `  headers: { 'Content-Type': 'application/json', ...config.headers },`,
      `})`,
      `if (!res.ok) throw new Error(\`HTTP \${res.status}: \${res.statusText}\`)`,
    )

    if (options.zod) {
      lines.push(
        `const json = await res.json()`,
        `return ${schemaVar}.parse(json) as ${responseType}`,
      )
    } else {
      lines.push(`return (await res.json()) as ${responseType}`)
    }

    return lines
  }

  private generateMutationFetcherBody(op: ApiOperation, options: GeneratorOptions): string[] {
    const responseType = this.getResponseTypeName(op.operationId)
    const hasParams = op.pathParams.length > 0 || op.queryParams.length > 0
    const hasBody = !!op.requestBody
    const schemaVar = `${toPascalCase(op.operationId).charAt(0).toLowerCase() + toPascalCase(op.operationId).slice(1)}ResponseSchema`

    let pathExpr = `'${op.path}'`
    if (op.pathParams.length > 0) {
      let tmpl = op.path
      for (const p of op.pathParams) {
        tmpl = tmpl.replace(`{${p.name}}`, `\${vars.params.${p.name}}`)
      }
      pathExpr = `\`${tmpl}\``
    }

    const lines: string[] = [
      `const config = getClientConfig()`,
      `const url = new URL(${pathExpr}, config.baseUrl)`,
    ]

    if (hasParams) {
      for (const p of op.queryParams) {
        lines.push(`if (vars.params.${p.name} !== undefined) url.searchParams.set('${p.name}', String(vars.params.${p.name}))`)
      }
    }

    lines.push(
      `const res = await fetch(url.toString(), {`,
      `  method: '${op.method}',`,
      `  headers: { 'Content-Type': 'application/json', ...config.headers },`,
    )

    if (hasBody) {
      lines.push(`  body: JSON.stringify(vars.body),`)
    }

    lines.push(
      `})`,
      `if (!res.ok) throw new Error(\`HTTP \${res.status}: \${res.statusText}\`)`,
    )

    if (options.zod) {
      lines.push(
        `const json = await res.json()`,
        `return ${schemaVar}.parse(json) as ${responseType}`,
      )
    } else {
      lines.push(`return (await res.json()) as ${responseType}`)
    }

    return lines
  }
}
