/**
 * SWR hook generator.
 *
 * Generates:
 * - useSWR hooks for GET operations
 * - useSWRMutation hooks for POST/PUT/PATCH/DELETE operations
 * - useSWRInfinite hooks for paginated GET operations
 */
import type { ApiOperation, ApiSpec, PaginationInfo } from '../ir/types'
import type { GeneratorOptions } from './types'
import { BaseHookGenerator } from './base-generator'
import { toPascalCase } from '../utils/naming'
import { getSwrKey } from '../utils/cache-keys'

export class SwrGenerator extends BaseHookGenerator {
  protected supportsInfiniteQueries(): boolean {
    return true
  }

  protected generateHookFile(
    op: ApiOperation,
    hookName: string,
    _spec: ApiSpec,
    options: GeneratorOptions,
  ): string {
    const isRead = this.isReadOperation(op)
    return isRead
      ? this.generateSwrHook(op, hookName, options)
      : this.generateSwrMutationHook(op, hookName, options)
  }

  protected generateInfiniteHookFile(
    op: ApiOperation,
    hookName: string,
    _spec: ApiSpec,
    options: GeneratorOptions,
  ): string | null {
    if (!op.pagination) return null
    return this.generateSwrInfiniteHook(op, hookName, op.pagination, options)
  }

  // ---------------------------------------------------------------------------
  // useSWR
  // ---------------------------------------------------------------------------

  private generateSwrHook(
    op: ApiOperation,
    hookName: string,
    options: GeneratorOptions,
  ): string {
    const paramsType = this.getParamsTypeName(op.operationId)
    const responseType = this.getResponseTypeName(op.operationId)
    const hasParams = op.pathParams.length > 0 || op.queryParams.length > 0
    const swrKey = getSwrKey(op)
    const schemaVar = `${toPascalCase(op.operationId).charAt(0).toLowerCase() + toPascalCase(op.operationId).slice(1)}ResponseSchema`

    const paramArg = hasParams ? `params: ${paramsType}` : ''
    const optionsArg = `options?: { enabled?: boolean }`
    const args = [paramArg, optionsArg].filter(Boolean).join(', ')

    const fetcherBody = this.generateFetcherBody(op, options)

    const lines: string[] = [
      `/**`,
      ` * ${op.summary || `${op.method} ${op.path}`}`,
      ` *`,
      ` * \`${op.method} ${op.path}\``,
      op.deprecated ? ` * @deprecated` : '',
      ` * Generated by auto-api-hooks — do not edit manually.`,
      ` */`,
      `import useSWR from 'swr'`,
      `import type { SWRConfiguration } from 'swr'`,
      `import { getClientConfig } from '../client'`,
      `import type { ${[paramsType, responseType].filter(Boolean).join(', ')} } from '../types'`,
    ].filter(Boolean)

    if (options.zod) {
      lines.push(`import { ${schemaVar} } from '../schemas'`)
    }

    lines.push(
      ``,
      `export function ${hookName}(${args}) {`,
      `  const key = options?.enabled === false ? null : ${swrKey}`,
      ``,
      `  return useSWR<${responseType}, Error>(key, async () => {`,
      ...fetcherBody.map((l) => `    ${l}`),
      `  })`,
      `}`,
      ``,
    )

    return lines.join('\n')
  }

  // ---------------------------------------------------------------------------
  // useSWRMutation
  // ---------------------------------------------------------------------------

  private generateSwrMutationHook(
    op: ApiOperation,
    hookName: string,
    options: GeneratorOptions,
  ): string {
    const paramsType = this.getParamsTypeName(op.operationId)
    const responseType = this.getResponseTypeName(op.operationId)
    const bodyType = op.requestBody ? this.getBodyTypeName(op.operationId) : null
    const hasParams = op.pathParams.length > 0 || op.queryParams.length > 0
    const schemaVar = `${toPascalCase(op.operationId).charAt(0).toLowerCase() + toPascalCase(op.operationId).slice(1)}ResponseSchema`

    // Build the arg type
    const argFields: string[] = []
    if (hasParams) argFields.push(`params: ${paramsType}`)
    if (bodyType) argFields.push(`body: ${bodyType}`)
    const argType = argFields.length > 0 ? `{ ${argFields.join('; ')} }` : 'void'

    const typeImports = [paramsType, responseType, bodyType].filter(Boolean).join(', ')

    const fetcherBody = this.generateMutationFetcherBody(op, options)

    const lines: string[] = [
      `/**`,
      ` * ${op.summary || `${op.method} ${op.path}`}`,
      ` *`,
      ` * \`${op.method} ${op.path}\``,
      op.deprecated ? ` * @deprecated` : '',
      ` * Generated by auto-api-hooks — do not edit manually.`,
      ` */`,
      `import useSWRMutation from 'swr/mutation'`,
      `import { getClientConfig } from '../client'`,
      `import type { ${typeImports} } from '../types'`,
    ].filter(Boolean)

    if (options.zod) {
      lines.push(`import { ${schemaVar} } from '../schemas'`)
    }

    lines.push(
      ``,
      `export function ${hookName}() {`,
      `  return useSWRMutation<${responseType}, Error, string, ${argType}>(`,
      `    '${op.method} ${op.path}',`,
      `    async (_key: string, { arg }: { arg: ${argType} }) => {`,
      ...fetcherBody.map((l) => `      ${l}`),
      `    },`,
      `  )`,
      `}`,
      ``,
    )

    return lines.join('\n')
  }

  // ---------------------------------------------------------------------------
  // useSWRInfinite
  // ---------------------------------------------------------------------------

  private generateSwrInfiniteHook(
    op: ApiOperation,
    hookName: string,
    pagination: PaginationInfo,
    options: GeneratorOptions,
  ): string {
    const paramsType = this.getParamsTypeName(op.operationId)
    const responseType = this.getResponseTypeName(op.operationId)
    const hasParams = op.queryParams.length > 1 || op.pathParams.length > 0
    const schemaVar = `${toPascalCase(op.operationId).charAt(0).toLowerCase() + toPascalCase(op.operationId).slice(1)}ResponseSchema`
    const nextPagePath = pagination.nextPagePath.join('?.')

    const paramArg = hasParams ? `params: Omit<${paramsType}, '${pagination.pageParam}'>` : ''
    const args = [paramArg].filter(Boolean).join(', ')

    let pathExpr = `'${op.path}'`
    if (op.pathParams.length > 0) {
      let tmpl = op.path
      for (const p of op.pathParams) {
        tmpl = tmpl.replace(`{${p.name}}`, `\${params.${p.name}}`)
      }
      pathExpr = `\`${tmpl}\``
    }

    const lines: string[] = [
      `/**`,
      ` * ${op.summary || `${op.method} ${op.path}`} (infinite)`,
      ` *`,
      ` * \`${op.method} ${op.path}\``,
      op.deprecated ? ` * @deprecated` : '',
      ` * Generated by auto-api-hooks — do not edit manually.`,
      ` */`,
      `import useSWRInfinite from 'swr/infinite'`,
      `import { getClientConfig } from '../client'`,
      `import type { ${[paramsType, responseType].filter(Boolean).join(', ')} } from '../types'`,
    ].filter(Boolean)

    if (options.zod) {
      lines.push(`import { ${schemaVar} } from '../schemas'`)
    }

    lines.push(
      ``,
      `export function ${hookName}(${args}) {`,
      `  const getKey = (pageIndex: number, previousPageData: ${responseType} | null) => {`,
      `    if (previousPageData && !(previousPageData as Record<string, unknown>)?.${nextPagePath}) return null`,
      `    const pageParam = pageIndex === 0`,
      `      ? undefined`,
      `      : (previousPageData as Record<string, unknown>)?.${nextPagePath}`,
      `    return [${pathExpr}, pageParam${hasParams ? ', params' : ''}] as const`,
      `  }`,
      ``,
      `  return useSWRInfinite<${responseType}, Error>(getKey, async ([_path, pageParam]) => {`,
      `    const config = getClientConfig()`,
      `    const url = new URL(${pathExpr}, config.baseUrl)`,
    )

    for (const p of op.queryParams) {
      if (p.name === pagination.pageParam) {
        lines.push(`    if (pageParam !== undefined) url.searchParams.set('${p.name}', String(pageParam))`)
      } else {
        lines.push(`    if (${hasParams ? `params.${p.name}` : 'undefined'} !== undefined) url.searchParams.set('${p.name}', String(${hasParams ? `params.${p.name}` : ''}))`)
      }
    }

    lines.push(
      `    const res = await fetch(url.toString(), {`,
      `      headers: { 'Content-Type': 'application/json', ...config.headers },`,
      `    })`,
      `    if (!res.ok) throw new Error(\`HTTP \${res.status}: \${res.statusText}\`)`,
    )

    if (options.zod) {
      lines.push(
        `    const json = await res.json()`,
        `    return ${schemaVar}.parse(json) as ${responseType}`,
      )
    } else {
      lines.push(`    return (await res.json()) as ${responseType}`)
    }

    lines.push(
      `  })`,
      `}`,
      ``,
    )

    return lines.join('\n')
  }

  // ---------------------------------------------------------------------------
  // Shared fetcher body generators
  // ---------------------------------------------------------------------------

  private generateFetcherBody(op: ApiOperation, options: GeneratorOptions): string[] {
    const responseType = this.getResponseTypeName(op.operationId)
    const schemaVar = `${toPascalCase(op.operationId).charAt(0).toLowerCase() + toPascalCase(op.operationId).slice(1)}ResponseSchema`

    let pathExpr = `'${op.path}'`
    if (op.pathParams.length > 0) {
      let tmpl = op.path
      for (const p of op.pathParams) {
        tmpl = tmpl.replace(`{${p.name}}`, `\${params.${p.name}}`)
      }
      pathExpr = `\`${tmpl}\``
    }

    const lines: string[] = [
      `const config = getClientConfig()`,
      `const url = new URL(${pathExpr}, config.baseUrl)`,
    ]

    for (const p of op.queryParams) {
      lines.push(`if (params.${p.name} !== undefined) url.searchParams.set('${p.name}', String(params.${p.name}))`)
    }

    lines.push(
      `const res = await fetch(url.toString(), {`,
      `  headers: { 'Content-Type': 'application/json', ...config.headers },`,
      `})`,
      `if (!res.ok) throw new Error(\`HTTP \${res.status}: \${res.statusText}\`)`,
    )

    if (options.zod) {
      lines.push(
        `const json = await res.json()`,
        `return ${schemaVar}.parse(json) as ${responseType}`,
      )
    } else {
      lines.push(`return (await res.json()) as ${responseType}`)
    }

    return lines
  }

  private generateMutationFetcherBody(op: ApiOperation, options: GeneratorOptions): string[] {
    const responseType = this.getResponseTypeName(op.operationId)
    const hasParams = op.pathParams.length > 0 || op.queryParams.length > 0
    const hasBody = !!op.requestBody
    const schemaVar = `${toPascalCase(op.operationId).charAt(0).toLowerCase() + toPascalCase(op.operationId).slice(1)}ResponseSchema`

    let pathExpr = `'${op.path}'`
    if (op.pathParams.length > 0) {
      let tmpl = op.path
      for (const p of op.pathParams) {
        tmpl = tmpl.replace(`{${p.name}}`, `\${arg.params.${p.name}}`)
      }
      pathExpr = `\`${tmpl}\``
    }

    const lines: string[] = [
      `const config = getClientConfig()`,
      `const url = new URL(${pathExpr}, config.baseUrl)`,
    ]

    if (hasParams) {
      for (const p of op.queryParams) {
        lines.push(`if (arg.params.${p.name} !== undefined) url.searchParams.set('${p.name}', String(arg.params.${p.name}))`)
      }
    }

    lines.push(
      `const res = await fetch(url.toString(), {`,
      `  method: '${op.method}',`,
      `  headers: { 'Content-Type': 'application/json', ...config.headers },`,
    )

    if (hasBody) {
      lines.push(`  body: JSON.stringify(arg.body),`)
    }

    lines.push(
      `})`,
      `if (!res.ok) throw new Error(\`HTTP \${res.status}: \${res.statusText}\`)`,
    )

    if (options.zod) {
      lines.push(
        `const json = await res.json()`,
        `return ${schemaVar}.parse(json) as ${responseType}`,
      )
    } else {
      lines.push(`return (await res.json()) as ${responseType}`)
    }

    return lines
  }
}
